---
import MainLayout from '../layouts/main.astro';
import AppointmentScheduler from '../components/AppointmentScheduler';
import { Toaster } from '../components/ui/sonner';
---

<MainLayout>
<div id="app-container" style="background: transparent;">
<!-- Fallback f√ºr wenn React nicht l√§dt -->
<noscript>
<div style="padding: 2rem; text-align: center; background: #fee2e2; color: #991b1b; border-radius: 0.5rem; margin: 2rem auto; max-width: 600px;">
<h2 style="font-size: 1.5rem; margin-bottom: 1rem;">JavaScript erforderlich</h2>
<p>Bitte aktivieren Sie JavaScript, um das Terminbuchungstool zu nutzen.</p>
</div>
</noscript>

<AppointmentScheduler client:only="react" />
<Toaster client:only="react" />
</div>
</MainLayout>

<style>
/* iFrame-spezifische Styles */
html.in-iframe,
html.in-iframe body {
/* Verhindere dass das iFrame scrollt - Parent soll scrollen */
overflow: visible !important;
height: auto !important;
min-height: 0 !important;
}

/* Touch-Action f√ºr besseres Scroll-Verhalten im iFrame */
html.in-iframe body {
touch-action: pan-y pan-x !important;
pointer-events: auto !important;
}

/* WICHTIG: Container muss sich zusammenziehen k√∂nnen */
html.in-iframe #app-container {
min-height: 0 !important;
height: auto !important;
}
</style>

<script>
// iFrame Auto-Resize: Sende H√∂hen-Updates an Parent Window
(function() {
// Pr√ºfe ob wir in einem iFrame sind
const isInIframe = window.self !== window.top;

if (!isInIframe) {
console.log('Nicht im iFrame - Auto-Resize deaktiviert');
return;
}

console.log('‚úÖ Im iFrame erkannt - starte Auto-Resize');

// Markiere HTML f√ºr iFrame-spezifische Styles
document.documentElement.classList.add('in-iframe');

let resizeTimeout = null;

function getActualHeight() {
// Finde den App-Container (das ist unser Content)
const container = document.getElementById('app-container');
const body = document.body;
const html = document.documentElement;
  
if (!container) {
console.warn('‚ö†Ô∏è App-Container nicht gefunden!');
return 600; // Fallback
}

// Messe den CONTAINER (nicht body/html!)
const containerRect = container.getBoundingClientRect();
const containerHeight = Math.ceil(containerRect.height);

// Addiere Padding/Margin vom body wenn vorhanden
const bodyStyle = window.getComputedStyle(body);
const bodyMarginTop = parseInt(bodyStyle.marginTop) || 0;
const bodyMarginBottom = parseInt(bodyStyle.marginBottom) || 0;
const bodyPaddingTop = parseInt(bodyStyle.paddingTop) || 0;
const bodyPaddingBottom = parseInt(bodyStyle.paddingBottom) || 0;

const totalPadding = bodyMarginTop + bodyMarginBottom + bodyPaddingTop + bodyPaddingBottom;
const height = containerHeight + totalPadding;

console.log('üìè Gemessene H√∂hen:', {
'container': containerHeight + 'px',
'body padding/margin': totalPadding + 'px',
'‚Üí Total': height + 'px'
});

return height;
}

function sendHeightToParent() {
try {
const height = getActualHeight();

// Sende die H√∂he IMMER (auch wenn kleiner)
window.parent.postMessage({
type: 'resize',
height: height
}, '*');

console.log('üì§ H√∂he gesendet:', height + 'px');

} catch (error) {
console.error('‚ùå Fehler beim Senden der H√∂he:', error);
}
}

// Debounced Resize
function debouncedResize() {
clearTimeout(resizeTimeout);
resizeTimeout = setTimeout(sendHeightToParent, 100);
}

// Initial mehrmals senden (React braucht Zeit zum Rendern)
console.log('‚è±Ô∏è Sende initiale H√∂hen...');
setTimeout(sendHeightToParent, 100);
setTimeout(sendHeightToParent, 300);
setTimeout(sendHeightToParent, 600);
setTimeout(sendHeightToParent, 1000);

// Bei DOM-√Ñnderungen (wenn Content hinzugef√ºgt/entfernt wird)
if (typeof MutationObserver !== 'undefined') {
const observer = new MutationObserver(function(mutations) {
console.log('üîÑ DOM-√Ñnderung erkannt:', mutations.length, 'mutations');
debouncedResize();
});

observer.observe(document.body, {
childList: true,        // Wenn Kinder hinzugef√ºgt/entfernt werden
subtree: true,          // In allen Nachkommen
attributes: true,       // Wenn Attribute √§ndern
characterData: true     // Wenn Text √§ndert
});

console.log('üëÄ MutationObserver aktiviert');
}

// Bei Gr√∂√üen√§nderungen (wenn Elemente ihre Gr√∂√üe √§ndern)
if (typeof ResizeObserver !== 'undefined') {
const resizeObserver = new ResizeObserver(function(entries) {
console.log('üìê Gr√∂√üen√§nderung erkannt:', entries.length, 'Elemente');
debouncedResize();
});

// Beobachte den CONTAINER statt body
const container = document.getElementById('app-container');
if (container) {
resizeObserver.observe(container);
console.log('üëÄ ResizeObserver aktiviert (auf #app-container)');
}

resizeObserver.observe(document.body);
resizeObserver.observe(document.documentElement);
}

// Bei Window-Resize
window.addEventListener('resize', function() {
console.log('ü™ü Window Resize');
debouncedResize();
});

// Fallback: Pr√ºfe regelm√§√üig
setInterval(function() {
sendHeightToParent();
}, 2000);

console.log('‚úÖ iFrame Auto-Resize vollst√§ndig aktiviert');
})();
</script>
